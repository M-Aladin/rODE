---
title: "Muskat Material Balance"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Muskat Material Balance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

For the Muskat's Material Balance equation:

$$\newcommand{\numD}{{\dfrac {S_o}{B_o B_g} \dfrac {dR_s}{dP} +  
\dfrac {S_o}{B_o} \dfrac {k_g}{k_o} \dfrac {\mu_o}{\mu_g} \dfrac {dB_o}{dP} + 
(1 - S_o - S_w) \dfrac {1}{B_g} \dfrac {dB_g}{dP} }}$$


$$\dfrac {dS_o}{dP} = \dfrac {\numD} {1 + \dfrac {k_g}{k_o} \dfrac {\mu_o}{\mu_g} }$$

All the terms on the right side are function of pressure ($P$) and saturation ($S$), the equation could be reduced to:

$$ \dfrac{dS}{dP} = f(P, S)$$

A first-order ordinary diferential equation (*ODE*).

## Plot a range of values for a given step size

Given the ODE:
$$ \dfrac{dS}{dP} = (2P +  S)$$

Find the first saturation values if the initial conditions are $P_o$ = 0, and $S_o$ = 1.

### We will use the Euler ODE solver


```{r message=FALSE, results="hold"}
library(rODE)
library(ggplot2)

setClass("MuskatEuler", slots = c(
    stack = "environment"                # environment object inside the class
    ),
    contains = c("ODE")
    )

setMethod("initialize", "MuskatEuler", function(.Object, ...) {
    .Object@stack$n <-  0               
    .Object@state   <- vector("numeric", 1)
    return(.Object)
})

setMethod("getState", "MuskatEuler", function(object, ...) {
    object@state
})

setMethod("getRate", "MuskatEuler", function(object, state, ...) {
    object@rate[1] <- state[1] + 2 * state[2]         # 2P + S
    object@rate[2] <- 1                               # dP/dP
    object@stack$n <- object@stack$n + 1              # add 1 to the rate count
    object@rate
})

# constructor
MuskatEuler <- function(P, S) {
    .MuskatEuler <- new("MuskatEuler")
    .MuskatEuler@state[1] = S        # S
    .MuskatEuler@state[2] = P        # P = t
    return(.MuskatEuler)
}
```


```{r}
# class implementation
MuskatEulerApp <- function(p_max = 1, stepSize = 0.01) {
    initial_S <- 1
    initial_P <- 0
    
    xmax      <- p_max
    stepSize  <- stepSize
    n_steps   <- as.integer((xmax + stepSize / 2) / stepSize)
    
    ode        <- MuskatEuler(initial_P, initial_S)
    ode_solver <- Euler(ode)
    ode_solver <- setStepSize(ode_solver, stepSize)
    
    steps <- 0
    rowVector <- vector("list")
    i <-  1
    while (steps < n_steps) {
        ode_solver <- step(ode_solver)
        state      <- getState(ode_solver@ode)
        steps      <- ode_solver@ode@stack$n
        rowVector[[i]] <- list(
                            P = state[2],     # x = t
                            S = state[1],     # y
                            steps = steps)
        i <- i + 1
    }
    data.table::rbindlist(rowVector)
}
```

```{r}
df <- MuskatEulerApp(p_max = 0.1, stepSize = 0.05)
df
```

```{r}
library(ggplot2)
ggplot(df, aes(P, S)) +
    geom_point()
```

```{r}
# get the error at the last row of the dataframe
df <- MuskatEulerApp(p_max = 0.25, stepSize = 0.1)
last_row <- df[nrow(df),]
last_row

last_saturation <- last_row$S
```



```{r}
# function that gets the error for different step sizes
get_last_saturation <- function(stepSize) {
    df <- MuskatEulerApp(p_max = 0.25, stepSize)
    last_row <- df[nrow(df),]
    last_saturation <- last_row$S
    c(step_size = stepSize, Sat = last_saturation, n_steps = last_row$steps)
}

step_sizes <- c(0.5, 0.1, 0.05, 0.01, 0.005, 0.001, 0.0001, 1e-5, 1e-6)
last_sat   <- data.frame(t(sapply(step_sizes, get_last_saturation)))
last_sat
```
